using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public enum SceneSerializationType {
	Class, // For saving levels that can be loaded into the editor and modified
	Instance, // For saving level states for users playing that level, cannot be edited by editor
	None // for extrneous objects we just want to clean up, they aren't in a list.
}



public class JsonLevelSaver : MonoBehaviour {

	public List<UserEditableObject> objsToExcludeFromSceneInstance = new List<UserEditableObject>(); 
	public static JsonLevelSaver inst;
	public RenderTexture levelScreenshot;

	public void SetInstance(){
		inst = this;
	}

	void Start(){
//		Debug.Log("first save completed:"+firstSaveCompleted);
		#if UNITY_EDITOR
//		ResetUndoHistory();
		//		ResetCurrentLevel();
		#else
//		ResetUndoHistory();

		#endif
//		UpdateRedoButtonClickability();
	}


	public void PreSaveLevelClass(){
		
		LevelBuilder.inst.saveDialogueSaveButton.SetActive(false); //hide save button immediately upon pressing to prevent double clicking it.
		// Saves a level class (as opposed to an instance)
		// which saves each piece needed to reconstitue a fresh level, 
		// e.g. Number Wall of dimension x y z at posiiton will be instantiated
		// and the bricks will be generated by the numberwall script

		AnalyticsManager.inst.RecordEvent(AnalyticsManager.Keys.timesSaveButtonPressed,1); //++;

		// Capture the inputs we put in for level name and description
		string levelName = LevelBuilder.inst.levelNameInput.text;
		string levelTags = LevelBuilder.inst.levelTagsInput.text;

		// If inputs were too short,
		// Throw an error by highlighting the input box in red for the user
		if (levelName.Length < 4) {
			LevelBuilder.inst.TempRedImage(LevelBuilder.inst.levelNameInput.gameObject);
			LevelBuilder.inst.saveDialogueSaveButton.SetActive(true);
//			Debug.Log("save button activeself:"+LevelBuilder.inst.saveDialogueSaveButton.activeSelf);
			return;
		}
//		if (levelTags.Length < 4) {
//			LevelBuilder.inst.TempRedImage(LevelBuilder.inst.levelTagsInput.gameObject);
//			LevelBuilder.inst.saveDialogueSaveButton.SetActive(true);
//			return;
//		}
		LevelBuilder.inst.levelTitle.text = levelName; // Set the user visible level name (doesn't work right now)



		// Check with the server if it's OK to save this level of this name with this user
		// (User is added to the query at the javascript stage in game_level_save.js
		WebGLComm.inst.VerifyValidSave(levelName); // Save is continued on callback

		
	}

	public void VerifyValidSaveCallback(bool flag){
		if (flag) {
			SaveLevel(SceneSerializationType.Class);
		} else {
			// Do nothing or
			// Display a message to user? Currently done with js.alert(message)
			LevelBuilder.inst.saveDialogueSaveButton.SetActive(true);
			WebGLComm.inst.Debug("<color=#09f>Saver:</color>ERROR: Could not save level, server save validation failed");
		}
	}

	public SimpleJSON.JSONClass GetSerializedLevelClassJson(){ 
		SimpleJSON.JSONClass N = GetLevelMetaData();
		N = JsonSerializeSceneObjects(N,SceneSerializationType.Class);
		InGameHUD.inst.SetUserAndLevelInfoText(WebGLComm.loggedInAsUser,N["Name"].Value);
		N["CharacterCostume"] = SimpleJSON.JSONClass.Parse(PlayerCostumeController.inst.characterJson);
		return N;
	}

	SimpleJSON.JSONClass SaveLevelClass(){
		WebGLComm.inst.Debug("<color=#09f>Saver:</color>.SaveLevelClass()");
		// Construct the json that will be sent to the server.
		SimpleJSON.JSONClass N = GetSerializedLevelClassJson();


		string screenshotData = Screenshotter.inst.GetCurrentScreenshotByteArrayAsString();

		#if UNITY_EDITOR
//		Debug.Log("editor save");
		PlayerPrefs.SetString("SavedClass",N.ToString());
		SaveLevelClassCallback();
		#endif
		WebGLComm.inst.SaveLevelClassToServer(JsonUtil.GetStringFromJson(N),screenshotData);

		return N;
	}

	public void SaveLevelClassCallback(){
		UpdateAutosaveText("Saved"); 
		LevelBuilder.inst.SaveLevelToServerCallback();
	}



	public SimpleJSON.JSONClass JsonSerializeSceneObjects(SimpleJSON.JSONClass N = null, SceneSerializationType serializationType = SceneSerializationType.Class){
		WebGLComm.inst.Debug("<color=#09f>Saver:</color>serializing scene with type: "+serializationType);
		if (N == null) N = new SimpleJSON.JSONClass();
		// Learn more about nesting json objects here: http://answers.unity3d.com/questions/1083933/simplejson-and-c-how-to-write-json-from-multiple-o.html
		// You need to figure out how to go from sipmlejson node to string http://answers.unity3d.com/questions/753058/get-a-json-string-from-a-simplejson-node.html

		// Make an empty list to be populated with objects we will be serializing
		List<UserEditableObject> ueos = new List<UserEditableObject>();
//		Debug.Log("ct before;"+ueos.Count);
		if (serializationType == SceneSerializationType.Class){
//			List<LevelBuilderSelectableObject> lbsos = new List<LevelBuilderSelectableObject>();
//			lbsos.AddRange(FindObjectsOfType<LevelBuilderSelectableObject>());
//			Debug.Log("bos:"+lbsos.Count);
			foreach(LevelBuilderSelectableObject lbso in FindObjectsOfType<LevelBuilderSelectableObject>()){
//				Debug.Log("add:"+lbso.name+", count:"+ueos.Count);
			
				ueos.Add(lbso.GetComponent<UserEditableObject>());

			}
		} else if (serializationType == SceneSerializationType.Instance) {
//			Debug.Log("serializing for INSTANCE");
//			Debug.Log("ct;"+ueos.Count);
			// Scene instance serialization looks at every possible object it can serialize
			foreach(UserEditableObject ueo in Utils.FindObjectsOfTypeInScene<UserEditableObject>()){
				if (ueo.IsSerializeableForSceneInstance()){
					ueos.Add(ueo);
				}
			}

		}

//		Debug.Log("ct after;"+ueos.Count);

		N["Objects"] = SerializeUserEditableObjects(ueos);


		return N;
	}


	public SimpleJSON.JSONArray SerializeUserEditableObjects(List<UserEditableObject> ueos, SceneSerializationType serializationType = SceneSerializationType.Class){
		WebGLComm.inst.Debug("<color=#09f>Saver:</color>.SerializeUserEditableObjects()");
		SimpleJSON.JSONArray objs = new SimpleJSON.JSONArray(); // Will be a list of objects

		foreach(UserEditableObject ueo in ueos){
			SimpleJSON.JSONClass obj = new SimpleJSON.JSONClass(); // Create a separate json sub-tree of user placed objects, which will be added to the main json after it's populated.
			obj = JsonUtil.GetUeoBaseProps(obj, ueo,serializationType);
			objs.Add(obj);
		}

		return objs;
	}

	bool ObjectIsSerializeable(UserEditableObject ueo, SceneSerializationType serializationType){
		switch(serializationType){
		case SceneSerializationType.Class:
			if (ueo.isSerializeableForClass) return true;
			break;
			case SceneSerializationType.Instance:
			if (ueo.IsSerializeableForSceneInstance()) return true;
			break;
			default:
			return false;
			break;
		}
		return false;


	}

	public string GetSavedLevelName(){
		return Utils.RealToFakeQuotes(LevelBuilder.inst.levelNameInput.text);
	}

	SimpleJSON.JSONClass GetLevelMetaData(){
		SimpleJSON.JSONClass N = new SimpleJSON.JSONClass();
		N["Name"] = GetSavedLevelName(); //Utils.RealToFakeQuotes(LevelBuilder.inst.levelNameInput.text);
		if (BackgroundAudioManager.inst.gameAudio != null){
			string ba = BackgroundAudioManager.inst.gameAudio.name;
			N["BackgroundAudio"] = ba;
			//			WebGLComm.inst.Debug("saved level class, bg audio:"+ba);
		} else {
			N["BackgroundAudio"] = "Null bga class";
			//			WebGLComm.inst.Debug("bg audio null during save class.");
		}

		N["Tags"] = Utils.RealToFakeQuotes(LevelBuilder.inst.levelTagsInput.text);
		N["Description"] = Utils.RealToFakeQuotes(LevelBuilder.inst.levelDescriptionInput.text);
		N["Terrain"] = MapManager.inst.currentMap.name.Replace("'",""); 
		N["AnimalBehaviorRules"] = AnimalBehaviorManager.inst.GetAnimalRules();
		N[LevelBuilderGroupManager.groupManagerKey] = LevelBuilderGroupManager.inst.GetProperties();
		N[GameManager.versionKey].AsFloat = GameManager.version;
		if (Screenshotter.inst.currentScreenshotCamera != null) N["ScreenshotCameraInfo"] = Screenshotter.inst.GetScreenshotCameraInfo();
//		WebGLComm.inst.Debug("terrain set;"+N["Terrain"].Value); 
		return N;
	}


	// Autosaving and Editor undo/redo
	static bool recursiveSavingEnabled = false;
	public void RecursiveSaveJson() {
		//		// commented Debug.Log("Recursive save.");
		recursiveSavingEnabled = true;
		recursiveSaveTimer = recursiveSaveInterval;
	}

	int maxSaves = 10;
	public void ResetUndoHistory(string origin="default"){ // rename to more appropriate like "StartNewSaveHistory" which include updating levelcode
		LevelBuilderEventManager.inst.ResetEvents();
		JsonLevelLoader.inst.SetTempLevelJsonPlayerPrefs("","reset undo");
//		PlayerPrefs.SetString("tempLevelJson",""); // clear
//		Debug.Log("reset undo hist.");
		JsonLevelLoader.inst.firstLoadCompleted = false;
//		PlayerPrefs.SetInt("currentSaveIndex",0);
//		// commented Debug.Log("Reset undo, origin:"+origin);
//		if (PlayerPrefs.HasKey("tempLevelJson_"+CurrentSaveIndex()) && PlayerPrefs.GetString("tempLevelJson_"+CurrentSaveIndex()) != "") {
//			SimpleJSON.JSONClass N = (SimpleJSON.JSONClass)SimpleJSON.JSONNode.Parse(PlayerPrefs.GetString("tempLevelJson_"+CurrentSaveIndex()));
//			if (N.GetKeys().Contains("Objects")) {
//				// commented Debug.Log("reset undo history. lost "+N["Objects"].AsArray.Count+" objects");
//			} else {
//				// commented Debug.Log("reset undo history (nothing cleared)");
//			}
//		} else {
//			// commented Debug.Log("reset undo history, no playerprefs to clear");
//		}
		autosaving.text = "Don't forget to save!";
		autosaved.enabled = false;
		saveWarningTimer = 0;
		saved = false;
		recursiveSavingEnabled = false;
		firstSaveCompleted = false;
		LevelBuilder.inst.fakePreviewButton.SetActive(true);
		LevelBuilder.inst.previewButton.SetActive(false);
//		LevelBuilder.inst.firstTimeOpened = true;
//		InGameHUD.inst.SetUserAndLevelInfoText(WebGLComm.loggedInAsUser,"Unsaved Level!");
//		currentUndos = 0;
//		for (int i=0;i<maxSaves;i++){
//			PlayerPrefs.SetString("tempLevelJson_"+i,""); // Reset temp level json for all i
//		}
	}

	public void ResetLevelNameAndDescription(){
		LevelBuilder.inst.levelNameInput.text = "unnamed level"; //termWebGLComm.loggedInAsUser+" s level";
		LevelBuilder.inst.levelTagsInput.text = "None";
		LevelBuilder.inst.levelDescriptionInput.text = "An awesome level by "+WebGLComm.loggedInAsUser;
	}


//	int maxUndos = 9;
//	int currentUndos = 0;
//	public void LevelBuilderUndo(){
//		AudioManager.inst.PlayInventoryClose();
////		Debug.Log("undo pressed");
//		if (HaveSaveOfIndex(CurrentSaveIndex()-1) && currentUndos < maxUndos){ 
//			float zoomLevel = LevelBuilder.inst.camSky.orthographicSize;
//			if (PlayerPrefs.HasKey("tempLevelJson_"+PlayerPrefs.GetInt("currentSaveIndex"))){
//				string json = PlayerPrefs.GetString("tempLevelJson_"+PlayerPrefs.GetInt("currentSaveIndex"));
//				if (json != ""){
//					// these checks, json=="", prevents 'undo' from calling LoadTempLevelJson with null json which causes clas to be loaded fresh.
//					// Todo: make this an incremental change index instead of saving/loading the whole json
//					IncrementPlayerPrefSaveIndex(-1);
//					currentUndos ++;
//					JsonLevelLoader.inst.LoadTempLevelJson(false);
//				}
//			}
//			LevelBuilder.inst.camSky.orthographicSize = zoomLevel; // hacky way to maintain previous zoom level after entire level is loaded with json
//		}
//	}
//
//	public void LevelBuilderRedo(){
//		//		// commented Debug.Log("redo pressed");
//		AudioManager.inst.PlayInventoryOpen();
//		if (HaveSaveOfIndex(CurrentSaveIndex()+1)){
//			currentUndos--;
//			IncrementPlayerPrefSaveIndex(1);
//			JsonLevelLoader.inst.LoadTempLevelJson(false);
//		}
//
//	}

//	void UpdateRedoButtonClickability(){
//		if (HaveSaveOfIndex(CurrentSaveIndex()-1)){
//			undoButton.interactable = true;
//			undoButton.GetComponent<UIHoverColor>().enabled = true;
//			foreach(Image im in undoButton.GetComponentsInChildren<Image>()){
//				im.color = Color.white;
//			}
//			undoButton.GetComponentInChildren<Text>().color = Color.white;
//
//		} else {
//			undoButton.interactable = false;
//			undoButton.GetComponent<UIHoverColor>().enabled = false;
//			foreach(Image im in undoButton.GetComponentsInChildren<Image>()){
//				im.color = Color.gray;
//			}
//			undoButton.GetComponentInChildren<Text>().color = Color.gray;
//
//		}
//		if (HaveSaveOfIndex(CurrentSaveIndex()+1)){
//			redoButton.interactable = true;
//			redoButton.GetComponent<UIHoverColor>().enabled = true;
//			foreach(Image im in redoButton.GetComponentsInChildren<Image>()){
//				im.color = Color.white;
//			}
//			redoButton.GetComponentInChildren<Text>().color = Color.white;
//
//		} else {
//			redoButton.interactable = false;
//			redoButton.GetComponent<UIHoverColor>().enabled = false;
//			foreach(Image im in redoButton.GetComponentsInChildren<Image>()){
//				im.color = Color.gray;
//			}
//			redoButton.GetComponentInChildren<Text>().color = Color.gray;
//
//		}
//	}
//

	public Text autosaving;
	public Image autosaved;
//	public Button undoButton;
//	public Button redoButton;

	public static bool firstSaveCompleted = false;

	static float recursiveSaveTimer = 0;
	public float recursiveSaveInterval = 90;
	float saveWarningTimer = 0;
	bool saved = false;

	void Update(){
		
		#if UNITY_EDITOR
		if (!LevelBuilder.inst.levelBuilderIsShowing){
			if (Input.GetKeyDown(KeyCode.I)){
				PlayerPrefs.SetString("tempinstance",SaveLevelInstance().ToString());
			}
			if (Input.GetKeyDown(KeyCode.O)){
				JsonLevelLoader.inst.LoadLevel(PlayerPrefs.GetString("tempinstance"),SceneSerializationType.Instance);
			}
		}
//		if (Input.GetKeyDown(KeyCode.S)){
////			Debug.Log("screenshot;" + Screenshotter.inst.GetCurrentScreenshotByteArrayAsString());
//		}
		if (Input.GetKey(KeyCode.S) && Input.GetKey(KeyCode.A) && Input.GetKey(KeyCode.V)){
			AutosaveNow();
		}
		#endif
//		if (recursiveSaveLevelInstance){ // This is simply too slow.
		// It's actually the .ToString method that is the slowest, not the iterating and populating the items..
		// seems Garbage Collect is causing a 1000 ms lag on big strings..

		if (recursiveSavingEnabled){
			recursiveSaveTimer -= Time.deltaTime;
			if (recursiveSaveTimer < 0){
				recursiveSaveTimer = recursiveSaveInterval;
				if (firstSaveCompleted){
					if (LevelBuilder.inst.levelBuilderIsShowing) {
						AutosaveNow();

					}
				} else {
					recursiveSavingEnabled = false; // This gets disabled if firstSaveCompleted is reset to False, which happens when we change the map. 
					// Reason being, changing the map should effectively reset everything about saving.. but we don't want to reload the 20mb client payload so we do a hacky reset with these fragile booleans!
				}
			}
		}
		if (!saved && LevelBuilder.inst.levelBuilderIsShowing){
			saveWarningTimer += Time.deltaTime;
			if (saveWarningTimer > 45){
				float s = 5;
				float r = 0.5f + (Mathf.Sin(Time.time * s) + 1)/4f;
				autosaving.color = new Color(r,0.5f,0.5f);
			} else if (saveWarningTimer > 120){
				float s = 15;
				float r = 0.5f + (Mathf.Sin(Time.time * s) + 1)/4f;
				autosaving.color = new Color(r,0.5f,0.5f);
			}
		}

	}

	public SimpleJSON.JSONClass SaveLevel(SceneSerializationType type){
		if (type == SceneSerializationType.Class) JsonLevelLoader.inst.state = LoadingState.SavingClass;
		if (type == SceneSerializationType.Instance) JsonLevelLoader.inst.state = LoadingState.SavingInstance;
		SimpleJSON.JSONClass N = null;
		if (type == SceneSerializationType.Instance){
			
			N = SaveLevelInstance();



		} else if (type == SceneSerializationType.Class){
			N = SaveLevelClass();
		}

//		Debug.Log("json save:"+N.ToString());
//		Debug.Log("string2");
//		string js = N.ToString();
//		if (js.Length > 20) js = js.Substring(0,20);
//		Debug.Log("saving:"+type.ToString()+",json:"+js);
		return N;
	}

	SimpleJSON.JSONClass SaveLevelInstance(){
		//Note that this was a performance bottleneck, NOT because of serialization (although that is still expensive)
		// but actually because of gettign a value of "string" out of Json object e.g. SimpleJson.ToString()
		//  Charlie improved performance by replacing tostring methods from string s = ""; s += "nextpiece" to StringBuilder sb = new StringBuilder(""); sb.append("nextpiece");
		// seems to speed up serialization (from existing complete SimpleJson.JsonCLASS object).ToString() A LOT e.g. 1 second to 0.2 seconds
		SimpleJSON.JSONClass N = new SimpleJSON.JSONClass();
		N = GetLevelMetaData();
		N = JsonSerializeSceneObjects(N,SceneSerializationType.Instance);


		#if UNITY_EDITOR

		PlayerPrefs.SetString("SavedInstance",N.ToString());
		#endif

		WebGLComm.inst.SaveLevelInstanceToServer(JsonUtil.GetStringFromJson(N));


		return N;
		
	}

	public void AutosaveNow(){ // For level builder
		WebGLComm.inst.Debug("<color=#09f>Saver:</color>autosave Now( "+Time.time);


//		Debug.Log("not returning");
		if (JsonLevelLoader.inst.state != LoadingState.Ready){
			WebGLComm.inst.Debug("<color=#09f>Saver:</color>Cannot autosave, state not ready");
			return;
		}
		SimpleJSON.JSONClass N = new SimpleJSON.JSONClass();
		N = GetLevelMetaData();
		N = JsonSerializeSceneObjects(N,SceneSerializationType.Class);
//		string json = N.ToString();
		string json = JsonUtil.GetStringFromJson(N); //.SaveToBase64();
		WebGLComm.inst.Autosave(json);
		JsonLevelLoader.inst.SetTempLevelJsonPlayerPrefs(json,"autosavenow");

	
		autosaving.text = "Autosaving ..";
		autosaved.enabled = false;
		WebGLComm.inst.Debug("<color=#09f>Saver:</color>Autosave Finished( "+Time.time);
	}

	public void UpdateAutosaveText(string s){
		autosaving.color = Color.white;
		saved = true;
		autosaving.text = s + " at " + System.DateTime.Now.ToString("h:mm tt"); 
		//			thisDate2); // string.Format("{0:yyyy-MM-dd}", System.DateTime);;
		autosaved.enabled = true;
		WebGLComm.inst.Debug("<color=#09f>Saver:</color>Autosave text Finished( "+Time.time);
	}

//	bool debugUndoFlow = false;
//	void IncrementPlayerPrefSaveIndex(int i, bool destroyNext=false){ // destroy next - we don't want to be able to "Redo" because we're at the end of the chain.
//		//		// commented Debug.Log("increment:"+i);
//		int newSaveIndex = (PlayerPrefs.GetInt("currentSaveIndex")+i);
//		if (newSaveIndex == -1) newSaveIndex = maxSaves-1;
//		newSaveIndex %= maxSaves;
//		PlayerPrefs.SetInt("currentSaveIndex",newSaveIndex);
//		if (debugUndoFlow) 		Debug.Log("updated save index:"+PlayerPrefs.GetInt("currentSaveIndex"));
//		if (destroyNext){
//			PlayerPrefs.DeleteKey("tempLevelJson_"+((CurrentSaveIndex()+1)%maxSaves).ToString());
//		}
////		UpdateRedoButtonClickability();
//	}


//	float undoSaveTimer = 0;
//	public void UpdateUndoHistory(bool timeoutConstrained = true){
//		// Try to save the level into the undo history buffer, if
//		if ((undoSaveTimer < 0  // interval time since last save has passed
//			|| !timeoutConstrained // or if we don't care about time (when pressed Preview)
//			&& !JsonLevelLoader.inst.levelIsBeingLoaded)){ // and that the level objects have finished loading int he editor (may fail if editor was just opened.
//			undoSaveTimer = 2.5f; // don't allow concurrent saves less than N seconds apart.
//			IncrementPlayerPrefSaveIndex(1,true);
//			currentUndos = 0;
//			SaveTempLevelJson();
//		}
//	}






}
